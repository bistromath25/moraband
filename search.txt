int search(State& s, SearchInfo& si, GlobalInfo& gi, int depth, int ply, int alpha, int beta, bool isPv, bool isNull, bool isRoot) {
	assert(depth >= 0);
	Move best_move = NULL_MOVE;

	si.nodes++; gi.nodes++;

	if (depth == 0) {
		return qsearch(s, si, gi, ply, alpha, beta);
	}
	if (!isRoot && (gi.history.isThreefoldRepetition(s) || s.insufficientMaterial() || s.getFiftyMoveRule() > 99)) {
		return DRAW;
	}
	
	// Mate distance pruning
	alpha = std::max((-CHECKMATE + ply), alpha);
	beta = std::min((CHECKMATE - ply), beta);
	if (alpha >= beta) {
		return alpha;
	}
	
	if (!(si.nodes & 2047) && (si.quit || interrupt(si))) {
		return 0;
	}

	// Probe tt
	bool tt_hit = false;
	int tt_score = NEG_INF;
	int tt_flag = -1;
	Move tt_move = 0;
	TTEntry tt_entry = tt.probe(s.getKey());
	//D(std::cout << s.getKey() << ' ' << tt_entry.getKey() << std::endl;);
	if (tt_entry.getKey() == s.getKey()) {
		tt_hit = true;
		tt_move = tt_entry.getMove();
		tt_score = value_from_tt(tt_entry.getScore(), s.getFiftyMoveRule());
		tt_flag = tt_entry.getFlag();
		if (!isPv && tt_entry.getDepth() >= depth) {
			if (tt_flag == FLAG_EXACT || (tt_flag == FLAG_LOWER && tt_score >= beta) || (tt_flag == FLAG_UPPER && tt_score <= alpha)) {
				return tt_score; // tt_score
			}
		}
	}

	// Check PV variation
	if (gi.variation.getPvKey(ply) == s.getKey()) {
		best_move = gi.variation.getPvMove(ply);
	}

	int staticEval = 0;
	if (!isPv) { // Evaluate current position statically if current node is NOT a PV node
		// TODO: use tt entry here
		Evaluate evaluate(s);
		staticEval = evaluate.getScore();
	}
	
	// Reverse futility pruning
	if (!isPv && !isNull && !s.inCheck() && depth <= 2 && s.getNonPawnPieceCount(s.getOurColor())) {
		if (staticEval - 150 * depth >= beta) {
			return staticEval; /* beta */
		}
	}

	// Null move pruning
	// Make a null move and search to a reduced depth and check
	//   Current node is not PV node
	//   Current state not in check
	//   Depth is high enough
	//   Enough non-pawn pieces on board
	if (!isPv && !isNull && !s.inCheck() && depth > NULL_MOVE_DEPTH && s.getNonPawnPieceCount(s.getOurColor()) > NULL_MOVE_COUNT) {
		State n;
		std::memmove(&n, &s, sizeof s);
		n.makeNull();
		gi.history.push(std::make_pair(NULL_MOVE, n.getKey()));
		int nullScore = -search(n, si, gi, depth - 3, ply + 1, -(alpha + 1), -alpha, false, true, false);
		gi.history.pop();
		if (nullScore >= beta) {
			return beta;
		}
	}

	// Internal iterative deepening
	// In case no best move was found, perform a shallower search to determine which move to properly seach first
	if ((isPv || staticEval + 100 >= beta) && !isNull && !s.inCheck() && best_move == NULL_MOVE && depth >= 5) {
		search(s, si, gi, depth - 2, ply, alpha, beta, isPv, true, false);
		tt_entry = tt.probe(s.getKey());
		if (tt_entry.getKey() == s.getKey()) {
			best_move = tt_entry.getMove();
		}
	}

	MoveList mlist(s, best_move, &(gi.history), ply); // Generate movelist

	int a = alpha;
	int b = beta;
	int d;
	int score;
	int bestScore = NEG_INF;
	Move m;
	bool first = true;
	int count = 0;
	
	while ((m = mlist.getBestMove())) {
		d = depth - 1; // Early pruning
		if (!isPv && bestScore > -CHECKMATE_BOUND && !s.inCheck() && !s.givesCheck(m) && s.getNonPawnPieceCount(s.getOurColor())) {
			// Futility pruning
			if (depth == 1 && s.isQuiet(m) && !isPromotion(m) && staticEval + 300 < a) {
				continue;
			}
			// SEE-based pruning (prune if SEE too low)
			// Prune if see(move) < -(pawn * 2 ^ (depth - 1))
			if (depth < 3 && s.see(m) < -PAWN_WEIGHT * (1 << (depth - 1))) {
				continue;
			}
		}

		State c(s);
		c.makeMove(m); // Make move
		gi.history.push(std::make_pair(m, c.getKey())); // Add move to history
		count++;

		if (c.inCheck() && depth == 1) {
			d++;
		}

		// Search first move
		if (first) {
			best_move = m;
			score = -search(c, si, gi, d, ply + 1, -b, -a, isPv, isNull, false);
			first = false;
		}     
		else {
			// Late move reduction
			// Seach with reduced depth under conditions described below
			// CPW: https://www.chessprogramming.org/Late_Move_Reductions
			if (count > LMR_COUNT && depth > LMR_DEPTH && !isPv && !s.inCheck() && !c.inCheck() && !s.isCapture(m) && !isPromotion(m)) {
				score = -search(c, si, gi, d - 1, ply + 1, -(a + 1), -a, false, isNull, false);
			}
			else {
				score = a + 1;
			}
			if (score > a) {
				score = -search(c, si, gi, d, ply + 1, -(a + 1), -a, false, isNull, false);
			}
			// If an alpha improvement resulted in a fail-high, search again with a full window
			if (a < score && b > score) {
				score = -search(c, si, gi, d, ply + 1, -b, -a, true, isNull, false);
			}
		}
		
		gi.history.pop(); // Pop move from gamelist

		if (score > bestScore) {
			best_move = m;
			bestScore = score;
		}

		a = std::max(a, bestScore);

		// Alpha-Beta pruning
		if (a >= b) {
			a = b;
			if (s.isQuiet(m)) {
				gi.history.update(m, depth, ply, true);
			}
			break;
		}
		else {
			if (s.isQuiet(m)) {
				gi.history.update(m, depth, ply, false);
			}
		}
	}

	if (bestScore == NEG_INF) { // Either completely lost or (hopefully) a draw
		return s.check() ? -CHECKMATE + ply : STALEMATE;
	}
	if (a > alpha && a < b && !si.quit) {
		gi.variation.pushToPv(best_move, s.getKey(), ply, a);
	}

	U64 flag = a >= b ? FLAG_LOWER
		: a > alpha ? FLAG_EXACT
			: FLAG_UPPER;
	
	tt.insert(best_move, flag, depth, value_to_tt(bestScore, s.getFiftyMoveRule()), s.getKey());

	// assert(variation.getPvMove() != NULL_MOVE);
	// Fail-Hard alpha beta score
	return a;
}